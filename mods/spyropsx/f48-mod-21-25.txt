###################################
Стр.21:
-ничего полезного-

###################################
Стр.22:

>> nihonjin:
Цитата (aleksusklim)
Cсылка на архив с программами и всем всем всем:
http://klimaleksus.narod2.ru/Files/1/ripbin.rar (83 Кб)

Цитата (aleksusklim)
Теперь можно очень легко модифицировать WAD без реального прожига образа. Алгоритм: 
1) Распакуйте весь мой архив (все пустышки-файлы там уже созданы) 
2) В «RipBin.txt» должно значится 24 на 2048 на 280 (кстати, значения по умолчанию если файла нет) 
3) Перетащите оригинальный BIN образ на «GetRip.bat» 
4) Появятся три файла «Spyro.rip», «Spyro.rip.sectorhead», «Spyro.rip.sectordata» (константа «Spyro» записана в «name.bat» и её можно сменить), общий размер которых должен быть строго равен размеру исходного BIN 
5) Перетащите «500`112793600`WAD.WAD» на «OneFileGET.bat» или просто запустите «AllFilesGET.CMD», если желаете получить сразу все файлы 
6) Модифицируйте WAD как пожелаете, либо замените его другим уже собранным файлом того же размера (в этом случае предыдущий пункт можно пропустить) 
7) Перетащите его же, «500`112793600`WAD.WAD» на «OneFileSAVE.bat» или запустите «AllFilesSAVE.CMD» (но это займёт больше времени) 
8) Создайте пустой файл (я это делаю через «Создать>Текстовый документ», а потом просто меняю расширение), назовите его как «.bin» и перетащите на «SaveBin.bat».

>> aleksusklim:
Есть! Я закончил новую версию PGG !

С проблемой ошибочного размера изображения так и не разобрался, зато выяснил, что обычный MsPaint после сохранения такой картинки делает её «нормальной» и вполне читаемой моим Дельфи. (То есть меньшая становится такая же, как и большая)

Взломал сам Paint (добавил горячие клавиши), написал к нему автоматизирующий скрипт на AutoIt и пихнул опцию в PGG. Ну короче, всё работает теперь.

Значит ещё раз, что я изменил в PGG2 :

1) Промежуточный формат хранения картинок.
Помните, как было? Сначала Any2pvV, потом вся череда PVV, Pvv2bmP , PGG, Bmp2Pvv, PVV, Pvv2anY… Плюс, каждая из них сильно тормозила.
Поэтому я переписал все свои Xxx2yyY на Sphinx C--. А он-то быстрый!
Только теперь я решил делать расчёт цветов не на стадии конвертирования, а только непосредственно в PGG2. То есть промежуточный BMP (рядом с DIB) очень тёмный, и не предназначен для иного редактирования, кроме как в PGG2. (Если что, можно выгрузить весь 15 бит и грузануть обратно).

2) Сопоставление цветов.
Раньше я делил на 31 и умножал на 255. Теперь я взял непосредственные значения из PVV. То есть поэкспериментировал и выяснил, каким цветам он сопоставляет 32 значения канала. Обратное преобразование делаю старым методом (деление на 255 и умножение на 31; однако я уже не доверил этот процесс функции Round(), а всё рассчитал сам на калькуляторе, вбив потом результаты в массив).
Однако исследования PVV привели к двум странностям:
– В режиме обычного просмотра 15 бит, «31» обозначает «255».
– В режиме 8/4 бит в палитре белый цвет «31» обозначает «248».
Получается, что PVV по-разному интерпретирует цвета, получаемые из пяти бит. Если это 15-битовое изображение, то происходит сглаживание. А если же это те же самые цвета, но используемые как палитра, то он тупо умножает на 8 каждое линейное значение битов.
Что делать? Сравнить с TileMolester!
Результат – он так вообще во ВСЕХ случаях линейно умножает на восемь. То есть, белого «255, 255, 255» цвета никогда не получится.
У меня было три варианта: либо делать сглаживание как в просмотре PVV, либо не делать его как в TileMolester, либо предложить пользователю опцию.
Я подумал-подумал, и принял первый вариант. Molester никогда не был для меня авторитетом, а вот PVV заслуживает уважения…

3) Целевой файл.
Отныне это не пара BMP-DIB, а наш самый обычный субфайл или суб-субфайл. Ничем предварительно не обработанный! Применяете свежеизвлечённый первый суб-субфайл любого субфайла уровня, и PGG2 сам передаёт его на конвейер Xxx2yyY, который вмиг (благодаря CMM) обрабатывает и возвращает ему пару BMP-DIB. Тот перезапускается и подбирает её.
При сохранении прямо противоположный процесс – он сохраняет пару, передаёт её конвейеру и конечным шагом копирует итоговый «.any» по заданному файлу для сохранения.
Однако есть недостаток – теперь конвейер жёстко привязан к системе PlayStation, хотя бы из-за 512 и 1024 по горизонтали. Теперь стало невозможно редактировать в PGG2 небольшие изображения в маленьких файлах (типа текстур драконьих яиц). Но можно что-нибудь придумать, если возникнет крайняя нужда.

4) Связь с PVV.
Я решил привязать PGG2 к всё тому же PVV. Теперь даже не придётся вручную устанавливать координаты копируемой области и местоположение палитры! Достаточно будет сделать это в визуальном режиме в PVV, закрыть его, и одним нажатием перенести все числа в PGG2, да сразу же экспортировать/импортировать части картинки.
PVV даже открывается сразу при старте PGG2 (с загруженным изображением), отображая то, что загрузилось. Ну потому что для того, чтобы что-то делать, пользователю всё равно придётся открывать картинку в PVV, прежде чем что-либо выгружать из неё. Теперь PVV открывается автоматически (а вообще, PGG2 сейчас работает только с загруженной в него картинкой – при запуске без параметров предлагает выбрать – то есть нельзя открыть его «вхолостую», вам обязательно нужно хоть что-то ему дать!), а ещё это каким-то образом устранило мощный глюк, при котором портились изображения в памяти – я не знаю, почему так происходило, но выяснил, что после запуска PVV такое более не повторяется, значит PVV будет запускаться самостоятельно каждый раз.

5) Автоматическая загрузка палитры
…теперь происходит ПОСЛЕ внедрения изображения. Прямо поверх него, если области перекрываются. Это был самый первый глюк, который следовало исправить. Отныне шрифт можно загружать одним действием, и его палитра появится в нём самом на нужном месте (правда там есть вторая палитра… Но её уже можно грузить отдельно, вместе с цветными кнопочками, к которым она относится)
А вообще, вместо флажка «Серый/Палитра» я сделал выбор из четырёх: «Серый, Только картинка, Только палитра, Всё сразу» (старый флажок соответствует первому и последнему варианту). По умолчанию стоит загрузка всего сразу (а это подразумевает исключительно восьмибитные картинки для PUT 8/4 бит). Отдельная загрузка только палитры поможет вытащить палитру из существующего BMP (не как внедрение палитры-цветной-полоски, а именно извлечение индексных цветов 8-битного изображения). Оставшиеся «Серый» и игнор палитры («Только картинка») тоже могут пригодиться, да и сделать их было не трудно.

6) Исправление плохих изображений.
Как раз то, с чего я начал. Флажок, действует на все PUT-команды. Предварительно копирует выбранный файл, открывает его через взломанный Paint, немного теребит его (инвертирует, отменяет, сохраняет, закрывает) через AutoIt, а потом отдаёт в PGG2. Можно поставить в том случае, если при обычной загрузке картинка внедрилась неправильно или не полностью.

Вот так:
http://klimaleksus.narod2.ru/Files/2/PGG2.PNG
(Нелогично да: прогу назвал PGG2, версия v1.1 а файл просто PGG.exe …)

Чтобы открыть файл, нужно перетащить его на EXE. Это должен быть первый суб-субфайл любого субфайла уровня (или что-то того же типа – редактор карты памяти, атлас, текстуры сценок, и.т.д…)
Либо можно запустить и выбрать в диалоговом окне. (Ну ещё можно перетащить BMP и DIB держа за BMP, но только те, которые были ранее скопированы из рабочей поддиректории \PGG.exe.res\ )

Основной процесс работы нового Палитрового Гения почти такой же, как и в прошлый раз:
http://www.spyro-realms.com/forum/48-11461-151384-16-1337284187
Объясню только новое:

1) Выставляете в PVV красную рамку и зелёную полоску на нужную область (например, шрифт или логотип)
2) Закрываете PVV и нажимаете «From PVV».
3) Извлекаете картинку нужной кнопкой.
Загрузить обратно изменённую ещё проще. Только не забудьте нажать «From PVV», если PGG2 был уже закрыт.

Флажок «Fix before put» – отметьте, если обычное внедрение не завершается успехом.

Ещё при внедрении полезно знать: (режимы 8 и 4 бит:)
«Full 8 bit» – внедрение сначала изображения, а потом его палитры;
«Image 8 bit» – внедрение только изображения, без его палитры;
«Palette 8 bit» – внедрение только палитры, без самого изображения;
«Grayscale 32 bit» (наверное надо было написать 24 бит…) – используйте только если выгружали с этой же опцией. Для четырёхбитных выглядит очень темновато…

Кнопка «View» немедленно открывает PVV ! В него также можно передать свои координаты из полей ввода, нажатием «To PVV».
Что за текстовое поле справа? Это пропуск нескольких верхних строк изображения. Потому что PVV отображает только 512, независимо от того, сколько ему передали.
А если вам нужно отредактировать 800-ю строку? Поставьте этот счётчик на 650 и увидите нижнюю часть своего файла.
Да более того, ещё и все координаты будут корректно сдвинуты, если выполнять два правила:
1) Перед каждым нажатием «View» давать команду «To PVV»
2) После закрытия PVV всегда нажимать «From PVV».

Ну а с «Save !» всё должно быть понятно. И да, если в файле ничего не менять или же внедрить изменённое содержимое обратно, то весь файл (претерпев многократное конвейерное конвертирование) будет снова один в один совпадать с оригинальным вплоть до CRC суммы! А это значит, что не надо бояться сохранять и загружать ранее сохранённую работу – ни одно сохранение не ухудшает качество!

Качайте:
http://klimaleksus.narod2.ru/Files/2/PGG2.rar

Исходники присутствуют – весь PGG, всё из CMM (4 штуки), AU3 – автоматизатор взломанного Paint (к последнему разумеется исходник не приложен, хотя я мог выдать патч от Ресторатора, но он вообще не будет никому нужен), и всё из папки «source» от PVV без каких-либо изменений.

Батами из «PGG.exe.res» можно пользоваться и самостоятельно. Все работают на перетаскивание одного файла:

«Any2pvV.bat» – раздвигает файл нулями так, чтобы сместить изображение на правую сторону для нормального открытия в PVV (и соответственно, PGG). Сохраняет в «*.pvv»
«Pvv2anY.bat» – обратное действие, удаляет холостые данные, чтобы вернуть файл в первоначальное состояние. Сохраняет в «*.any»
«Pvv2bmP.bat» – расшифровывает файл и расщепляет его на BMP и DIB. Где в BMP хранится раздельно результирующее значение цвета каждого пикселя (от 0 до 31, тёмно), а в DIB – белый, если шестнадцатый бит единичный, и чёрный, если нулевой. Сохраняет в «*.bmp» и «*.bmp.dib»
«Bmp2pvV.bat» – обратное действие, сливает пару BMP и DIB в единый 15-битный файл. Перетаскивать надо только BMP, при этом DIB берётся как «*.dib». Побочный эффект – сперва создаются копии «*~.bmp» и «*.dib~.dib» – они будут отражёнными по вертикали (необходимо для корректного считывания, ибо все файлы Bitmap хранятся задом наперёд). Сохраняет в «*.pvv»
«Any2bmP.bat» – конвейерно производит сразу два действия – «Any2pvV.bat» и «Pvv2bmP.bat», предварительно копируя оригинал в «file.any»
«Bmp2pgG.bat» – передаёт пару BMP и DIB (перетащенные за BMP, а DIB как «*.dib») в родительский каталог в PGG.exe
«Any2pgG.bat» – конвейерно все действия: «Any2bmP.bat» (который сам состоит из двух) и «Bmp2pgG.bat».
«Pgg2anY.bat» – берёт пару «file.any.pvv.bmp.new.bmp» + «file.any.pvv.bmp.new.bmp.dib» и передаёт её конвейерно на «Bmp2pvV.bat» и «Pvv2anY.bat». После чего копирует «file.any.pvv.bmp.new.bmp.pvv.any» в «*».
«Mspaint_use.bat» – копирует перетащенный файл в «file.mspaint.bmp», а потом запускает на него «Mspaint_use.exe», который заставляет «Mspaint_mini.exe» пересохранить файл по тому же имени.

Во всех командах я обозначил звёздочкой «*» – тот файл, который был перетащен.
Все мои программы из CMM нельзя просто так запускать или перетаскивать на них что-либо непосредственно, я поставил защиту как переменную «set f0=!!!» без которой они автоматически закрываются, но всё же лучше не рисковать, ибо никакого отлова ошибок
(например, несуществующие или заблокированные файлы, неверные символы, папки только для чтения и.т.д.) я не предусмотрел. Программы могут зависнуть или испортить целевые файлы (бесконечно заполнять нулями), но обычно они просто закрываются, ничего не делая.
В «Mspaint_mini.exe» мои горячие клавиши – «F5 = Ctrl+I», «F6 = Ctrl+Z», «F7 = Ctrl+S».
«Mspaint_use.exe» по сути делает запуск с параметром, затем «F5, F6, F7, Alt+F4», на время блокируя пользовательский ввод (мышь перестаёт отвечать – обычно на 1-2 секунды, ограничение худшего случая – 10 сек; но Ctrl+Alt+Delete вернёт движение в любом случае, если что) и требует, чтобы открываемое изображение обязательно называлось «file.mspaint.bmp» (хотя можно было и как опциональный аргумент запрограммировать…)

«PVV.exe» – всё тот же PVV (ужатый через UPX, как и остальное). PGG2 принимает все координаты из файла «PVV.ini» (благо, PVV написан на Delphi как и мой PGG, так что библиотека парсинга ini-файлов универсальна и удобна в применении).

###################################
Стр.23:
-ничего полезного-

###################################
Стр.24:
-ничего полезного-

###################################
Стр.25:

>> aleksusklim:
Я взломал кодировку «мясорубки» таблички и любой похожей графики.

Расшифровать могу однозначно, а вот собрать обратно пока не пробовал, но кажется, что будет бесконечно много вариантов, надо убедится, что игра примет любой.

Итак, формат:
0) Переходим к началу исходного файла.
1) Считываем очередные два байта.
2) Назовём первый NUL, а второй CPY.
3) Удваиваем оба.
4) Пишем в выходной файл NUL нулей.
5) Копируем из исходного файла в выходной CPY байт.
6) Переходим к пункту 1 из текущей позиции.
7) Выйти из цикла нужно, когда будет достигнут конец исходного файла.

Получается, что данные сплошь пронизаны индексами, которые не могут отстоять друг от друга более чем на 510 байт (255*2).

Естественно, написал конвертер.

Поскольку размеры конечного файла не обязаны быть 512 пикселей по ширине, нужен ещё метод принудительного раздвигания строчек, чтобы открывать в PGG.

Однако нам повезло, и табличка имеет ширину ровно 512, так что выходной файл моего алгоритма можно напрямую подавать на вход PGG2, как если бы это был субфайл с тайлами.

Пока единственный глюк – табличка как бы сдвинута, её будет нужно разрезать и переставить части местами, а именно:
http://klimaleksus2.ucoz.ru/Files/GH/logo_23.png

Скорее всего, табличка именно так и располагается в ресурсах.
Если найдёте другую графику, пропущенную через мясорубку, то обязательно проверьте мою программу и на ней. А вот собственно и программа:
http://klimaleksus2.ucoz.ru/Files/2/strip.rar

Перетащите шестой субфайл на «strip.bat», а полученный .new на PGG.exe (лучше уже с заплаткой)

И подумайте, как именно будем конвертить наше лого обратно. Похоже, понадобится ещё одна программа, которая сделает все ПОЧТИ чёрные пиксели абсолютно чёрными, чтобы наша кучка полосок не превзошла по объёму оригинальную, а ведь чёрного цвета у нас явно меньше…

А насчёт изменения размеров и добавления пустоты – если картинка меньше 512, то можно будет её раздвинуть, зная оригинальный размер (через TileMolester или мой PictureViewer.pas) – вызовите strip.exe с такими параметрами: «исходный файл» «целевой файл» «оригинальная ширина» «новая ширина»
